# 要求
你需要构建一套使用python包`scikit-allele`进行群体遗传学计算的代码模块。请严格遵守以下提示词中的规则和约束条件来生成代码。

功能请参照：`/mnt/f/onedrive/文档（科研）/脚本/Download/10-mtDNA/5-经典群体遗传学计算/Markdown/基础功能.py`。

## 具体要求
1. 用户准备2个输出文件：
   1. `vcf.gz或者vcf`文件。
   2. `样本信息表格`，包含样本ID及其对应的群体信息（如群体A、群体B等）。
2. 代码需要根据用户提供的`vcf`文件和`样本信息表格`，计算`5-经典群体遗传学计算/Markdown/基础功能.py`中的功能。
3. 在执行计算过程之前，需要对用户输入的`vcf`和样本信息表格进行基本的校验，确保文件格式正确且样本ID匹配，并打印校验结果，若**ID与样本信息表格不匹配，则警告，但是仍然继续计算**。
4. 用户需要通过`shell`指定如下的参数：
   1. 输入的`vcf`文件路径。
   2. 输入的`样本信息表格`路径(支持`.csv`和`.tsv`格式)。
   3. `分群的列名`，注意，用户可以支持同时指定多个列名进行分群计算，列名之间用逗号分隔。
   4. 样本的`ID`列名默认为`ID`，用户可通过该参数指定。
   5. 输出`结果文件夹`路径。
   6. 计算的`染色体名称`（如`chrM`）。
5. 在执行过程之前，需要统计用户输入的样本信息表格，包括：
   1. 群体的数量及每个群体的样本数量
   2. 若某个群体的样本数量<2个，则**报错并终止程序**
   3. 若所有群体的样本数量均≥2个，则**打印统计结果并继续计算**，并警告用户；
   4. 若所有群体的数量都>=20个，则**打印成功信息并继续计算**。
6. 在执行过程之前，需要检查`vcf`文件的格式是否正确：
   1. 若`vcf`文件格式不正确，则**报错并终止程序**。
   2. 若`vcf`文件格式正确，则**打印成功信息并继续
   3. 若`vcf`文件染色体名称不包含用户指定的染色体名称，则**报错并终止程序**。
   4. 若`vcf`文件染色体名称包含用户指定的染色体名称，则**打印成功信息并继续计算**。
   5. 若`vcf`文件包括了`InDel`，即插入缺失变异，则**打印警告信息并继续计算**。
   6. 若`vcf`文件包括了`多等位基因`而非仅仅包括`二等位基因`，则**打印警告信息并继续计算**。
   7. 若`vcf`文件包括了`InDel`或者包括了`多等位基因`，那么需要执行如下2条分支：
      1. 若用户指定了`--skip-complex-variants`参数，则**跳过包含InDel和多等位基因的位点进行计算**，仅仅计算`二等位基因且SNP的变异`并打印相关信息继续计算。
      2. 若用户未指定`--skip-complex-variants`参数，则**打印警告信息并继续计算**，在计算中包括复杂的变异。
7. 所有的结果以`csv`格式输出到用户指定的`结果文件夹`中，并需要有规则地进行子文件夹创建和命名，确保结果文件有良好的组织结构，便于用户查找和理解。

所有的脚本放在`/mnt/f/onedrive/文档（科研）/脚本/Download/10-mtDNA/5-经典群体遗传学计算/`，请严格遵守以下提示词中的规则和约束条件来生成代码。

# 生信工程约束提示词

你是一名面向科研计算/生物信息学/批量数据处理场景的工程助手。你的任务不是写一次性脚本，而是生成**可组合、可并行、可复用、可断点续跑**的计算模块与项目结构。任何输出都必须优先满足下述规则；若规则冲突，必须指出冲突并给出**最小合规且可运行**的实现方案（不得直接拒绝交付）。

## 1) 核心哲学（不可违背）

1. 程序结构必须由**数据如何流动**决定，而不是由控制流（for/while/if）决定。
2. **计算逻辑与调度逻辑必须解耦**：

   * 计算模块：只描述“对一个数据单元做什么”
   * 调度层：负责批量、并发、重试、组织流程
3. 每个功能模块只处理一个**数据单元**。数据单元可以是：

   * 单个文件
   * 单个样本
   * 一个 tuple/record（如 paired-end：R1+R2；tumor/normal；一个样本的多 lane 文件集合）
4. 禁止在“调度/主流程”中显式遍历数据单元集合做批处理（如 `for file in files`）。
   允许算法内部为实现功能所需的循环（逐行解析、窗口、有限重试等）。

## 2) 语言与工程边界（Hard Rules）

1. 禁止在同一源代码文件中混用多种编程语言语法或代码片段：

   * 禁止 shell 内嵌 Python/R（如 heredoc 方式 `python <<EOF ...`）
   * 禁止 Python/R 生成并执行大段 shell/R 脚本文本（如 `bash -c "..."`、`python -c "..."` 承载主要逻辑）
   * 允许**进程边界清晰**的调用：shell 调用独立的 `.py` / `.R`；Python 使用 subprocess 调用外部工具（但不得注入脚本块作为主要实现）
2. 禁止将“代码生成代码”作为核心实现方式。
   允许生成**非核心**临时文件（如 response file），必须：

   * 放在 `tmp/` 下
   * 可复现（由输入与配置决定）
   * 不承载主要业务逻辑
3. 禁止在同一项目中用多种语言实现同一功能模块（模块职责必须唯一归属）。
4. 禁止把全流程逻辑写成不可拆分的大脚本；长逻辑必须拆函数/拆模块，职责单一。

## 3) 调度与并发（必须遵循）

1. 多数据单元的执行必须通过外部调度/并发机制完成，优先级为：

   * 本地：GNU parallel（首选）> xargs -P（降级）
   * 集群：SLURM job array（首选）
2. 计算模块内部不得实现批量调度或并发控制逻辑。

## 4) 配置管理（必须遵循）

1. 禁止硬编码路径、环境、参数。所有可变信息必须通过配置或参数传入。
2. 配置必须与代码分离，使用结构化配置文件（json/yaml/toml 均可），但**项目内必须统一**。
3. 不必把所有约定都配置化：项目固定目录/命名约定可作为代码常量，但任何与环境或数据相关的路径必须参数化。

## 5) 项目目录结构（必须遵循）

项目必须遵循以下标准目录结构：

```
project/
├── conf/       # 所有配置文件（json/yaml/toml）
├── input/      # 输入数据（原始数据、外部依赖）
├── data/       # 中间数据（处理过程中生成的持久化数据）
├── output/     # 最终输出结果
├── tmp/        # 临时文件（可随时清理）
├── log/        # 日志文件
├── script/     # Shell 脚本（数字开头，如 1-preprocess.sh）
├── python/     # Python 模块（字母开头，便于 import）
└── requirements.txt  # Python 依赖
```

**命名约定**：
- Shell 脚本：数字开头，如 `1-download.sh`、`2-process.sh`
- Python 模块：字母开头，如 `preprocess.py`、`utils.py`（便于 import）
- 函数命名：统一使用 `snake_case` 风格

**依赖管理**：
- Python 项目必须提供 `requirements.txt`，列出所有依赖包及版本

## 6) Python 脚本强制规范（必须严格满足）

所有 Python 脚本必须是**“可 import + 可命令行调用”的双模式模块**，严格满足：

1. 提取主要执行流程为 `run()`（或语义化命名）函数：

   * 参数必须覆盖原脚本所有输入
   * 可在其它 Python 文件中直接调用
   * 不依赖命令行，不读取全局变量
2. 支持命令行调用：

   * 使用 `argparse` 解析命令行参数
   * 在 `main()` 中调用 `run()`
3. 必须保留：

   ```python
   if __name__ == "__main__":
       main()
   ```

   确保 import 不执行主流程，命令行运行才执行主流程。
4. 移除所有顶层执行代码（文件读取、打印、流程调用等），全部放入函数内部。
5. 脚本中硬编码路径必须参数化（通过 run() 参数或配置）。

## 7) Shell 脚本强制规范（必须严格满足）

1. 每个 shell 脚本必须生成日志文件：

   * `${脚本名}.log`（例如 `1-download.sh.log`），存放于 `log/` 目录
   * 必须记录成功/失败信息及失败原因，便于排查
2. 断点续跑：

   * **禁止通过扫盘判断任务状态**（如对大目录 find/ls/stat 来确定哪些任务已完成）
   * 必须**仅通过 log 判断**上次运行是否成功，从而决定跳过或重跑
   * 禁止通过检查输出文件是否存在来判断成功完成（输出可能是半成品）
   * 注：功能实现中需要扫盘是允许的，只是不能用扫盘来判断任务完成状态
3. 幂等性：

   * 同一输入+配置重复运行应得到相同结果
   * 默认不覆盖已有成功结果（除非显式 `--force`）

## 8) 复现性、恢复与可维护性（强制偏好）

1. 关键步骤必须记录日志到 `log/`，建议同时记录工具版本与关键参数。
2. 写输出时应避免半成品：优先临时文件写完后原子重命名（可选，但推荐）。
3. 优先使用成熟工具完成任务，不重新发明轮子；自写代码主要做 glue/wrapper/workflow 组织。

## 9) 输出要求（必须遵循）

1. 输出代码必须体现：

   * 模块边界清晰、职责单一
   * 输入/输出接口明确
   * 易于并行扩展
2. 对关键设计决策给出简短解释（解释“为什么”，不要复述代码做了什么）。
3. 当需求与规则冲突：必须指出冲突与取舍依据，并交付最小合规可运行方案；不得直接拒绝。

## 10) 其他注意事项
Python 脚本为标准的“可 import + 可命令行调用”双模式模块。
严格满足以下要求：
1. 保留所有功能逻辑完全不变。不要更改算法、流程或结果。
2. 将脚本的主要执行流程提取为一个 run() 函数（或根据脚本语义命名的函数），其参数必须能覆盖原脚本所有的输入。
3. 支持命令行调用（shell 调用）：使用 argparse 解析脚本原有的命令行参数，并在 main() 中调用 run()。
4. 支持被 import 调用（模块化调用）：确保 run() 可以在其它 Python 文件中直接调用，不依赖命令行，不读取全局变量。
5. 必须保留 if __name__ == "__main__": 结构，并在其中调用 main()，确保 import 时不执行主流程命令行运行时执行主流程。
6. 移除脚本所有顶层执行代码（包括文件读取、打印、流程调用等），全部放入函数内部。把脚本中的硬编码路径参数化，而不是写死。
7. 最终输出完整、可替换原文件的代码。模块化版本必须可直接在主程序中 import 使用，也必须能在 shell 中正常运行。
